Filename: Classes.py
Path: Classes.py

import os
import pandas as pd
from utils import *
from evaluation import *

class Server:
    def __init__(self, givens, generation, latency, data_center, identifier):
        self.generation = generation
        self.latency_sensitivity = latency
        self.data_center = data_center
        self.identifier = identifier
        # Using properties to dynamically fetch data when needed
        self._givens = givens
        self.deployed = False
        self.operational_time = 0

    @property
    def status(self):
        return {
            "type": self.generation,
            "capacity_used": self.capacity if self.deployed else 0,
            "uptime": self.operational_time,
            "latency_sensitivity": self.latency_sensitivity
        }

    @property
    def server_data(self):
        # Dynamically fetches server data
        return self._givens.servers_df[self._givens.servers_df['server_generation'] == self.generation].iloc[0]

    @property
    def selling_price_data(self):
        # Dynamically fetches selling price data
        return self._givens.selling_prices_df[self._givens.selling_prices_df['server_generation'] == self.generation]

    @property
    def capacity(self):
        return self.server_data['capacity']

    @property
    def slots_needed(self):
        return self.server_data['slots_size']

    @property
    def energy_consumption(self):
        return self.server_data['energy_consumption']

    @property
    def purchase_price(self):
        return self.server_data['purchase_price']

    @property
    def life_expectancy(self):
        return self.server_data['life_expectancy']

    @property
    def cost_of_moving(self):
        return self.server_data['cost_of_moving']

    @property
    def maintenance_fee(self):
        return self.server_data['average_maintenance_fee']

    @property
    def selling_price(self):
        # Dynamic fetching based on latency sensitivity
        price_row = self.selling_price_data[self.selling_price_data['latency_sensitivity'] == self.latency_sensitivity]
        return price_row['selling_price'].iloc[0] if not price_row.empty else None

    def age_server(self):
        if self.deployed:
            self.operational_time += 1
            if self.operational_time >= self.life_expectancy:
                self.decommission()

    def deploy(self):
        self.deployed = True
        self.remaining_life = self.life_expectancy
        self.operational_time = 0

    def decommission(self):
        self.deployed = False
        print(f"Server {self.identifier} decommissioned.")

    def update_life(self, time):
        self.remaining_life -= time
        self.operational_time += 1
        if self.remaining_life <= 0 or self.operational_time >= self.life_expectancy:
            self.decommission()

    def update(self):
        '''
        Updates the aging and time_step of the server for one time step.
        '''
        self.update_life(1)

class DataCenter:
    def __init__(self, givens, identifier):
        self._givens = givens
        self.identifier = identifier
        self.datacenter_data = self._givens.datacenters_df[self._givens.datacenters_df['datacenter_id'] == identifier].iloc[0]
        self.servers = []  # List of Server objects
        self.operational_time = 0
    
    def deploy_server(self, server_type, quantity):
        print(f"Deploying {quantity} servers of type {server_type} in data center {self.identifier}")
        print("self._givens.servers_df")
        print(self._givens.servers_df)
        '''
        Deploying 0 servers of type 0 in data center DC1
        > self._givens.servers_df:
        server_generation server_type release_time  purchase_price  slots_size  energy_consumption  capacity  life_expectancy  cost_of_moving  average_maintenance_fee
        0            CPU.S1         CPU       [1,60]           15000           2                 400        60               96            1000                      288
        1            CPU.S2         CPU      [37,96]           16000           2                 460        75               96            1000                      308
        2            CPU.S3         CPU     [73,132]           19500           2                 800       120               96            1000                      375
        3            CPU.S4         CPU    [109,168]           22000           2                 920       160               96            1000                      423
        4            GPU.S1         GPU       [1,72]          120000           4                3000         8               96            1000                     2310
        5            GPU.S2         GPU     [49,120]          140000           4                3000         8               96            1000                     2695
        6            GPU.S3         GPU     [97,168]          160000           4                4200         8               96            1000                     3080
        '''
        # Check if the server type exists in the DataFrame
        filtered_df = self._givens.servers_df[self._givens.servers_df['server_type'] == server_type]
        if filtered_df.empty:
            print(f"No server type '{server_type}' found.")
            return
        
        server_info = filtered_df.iloc[0]
        slots_needed = server_info['slots_size'] * quantity
        
        if self.empty_slots >= slots_needed:
            for _ in range(quantity):
                new_server = Server(self._givens, server_type, self.datacenter_data['latency_sensitivity'], self, f"{self.identifier}_new_{server_type}")
                self.servers.append(new_server)
                new_server.deploy()
                print(f"Deployed server {server_type} in data center {self.identifier}")
        else:
            print(f"Not enough slots to deploy {quantity} servers of type {server_type}. Available slots: {self.empty_slots}, needed: {slots_needed}")

    def get_total_maintenance_cost(self):
        return sum(server.maintenance_fee for server in self.servers if server.deployed)

    def get_total_energy_cost(self):
        return sum(server.energy_consumption for server in self.servers if server.deployed) * self.cost_of_energy

    def summary(self):
        return {
            "total_capacity": sum(server.capacity for server in self.servers),
            "available_capacity": sum(server.capacity for server in self.servers if not server.deployed),
            "energy_cost": self.cost_of_energy,
            "servers": [server.status for server in self.servers]
        }

    @property
    def slots_capacity(self):
        return self.datacenter_data['slots_capacity']

    @property
    def cost_of_energy(self):
        return self.datacenter_data['cost_of_energy']

    @property
    def latency_sensitivity(self):
        return self.datacenter_data['latency_sensitivity']

    @property
    def filled_slots(self):
        return sum(server.slots_needed for server in self.servers if server.deployed)

    @property
    def empty_slots(self):
        return self.slots_capacity - self.filled_slots

    def add_server(self, server):
        if self.can_add_server(server):
            self.servers.append(server)
            server.deploy()
            print(f"Server {server.generation} added to {self.identifier}")
        else:
            print("Error - Adding Servers - Not enough slots to add this server")

    def remove_server(self, server):
        if server in self.servers:
            self.servers.remove(server)
            server.decommission()
            print(f"Server {server.generation} removed from {self.identifier}")
        else:
            print("Error - Removing Servers - Server not found in data center")

    def update(self):
        '''
        Updates the aging and time_step of the data center for one time step, including all servers.
        '''
        self.operational_time += 1
        for server in self.servers:
            server.update_life(1)

    def can_add_servers(self, required_slots):
        """
        Check if the data center has enough empty slots to accommodate a given number of slots.
        
        Args:
            required_slots (int): Number of slots required for new servers.

        Returns:
            bool: True if there is enough capacity, False otherwise.
        """
        return self.empty_slots >= required_slots

    def __str__(self):
        return f"DataCenter {self.identifier}: Capacity {self.slots_capacity}, Empty Slots {self.empty_slots}"

class Inventory:
    def __init__(self, givens):
        self._givens = givens
        self.datacenters = [DataCenter(givens, dc_id) for dc_id in self._givens.datacenters_df['datacenter_id']]
        self.operational_time = 0
        self.delta_moving_cost = 0
        self.delta_purchase_cost = 0
        self.current_moving_cost = 0
        self.current_purchase_cost = 0

    def get_datacenter_by_id(self, identifier):
        """ Returns the datacenter object by its identifier. """
        return next((dc for dc in self.datacenters if dc.identifier == identifier), None)
    
    def get_total_costs(self):
        energy_cost = sum(dc.get_total_energy_cost() for dc in self.datacenters)
        maintenance_cost = sum(dc.get_total_maintenance_cost() for dc in self.datacenters)
        return {
            'energy_cost': energy_cost,
            'maintenance_cost': maintenance_cost,
            'purchase_cost': self.current_purchase_cost,
            'moving_cost': self.current_moving_cost
        }
    
    def get_aggregated_server_capacities(self):
        """ Aggregates server capacities by server generation across all datacenters. """
        capacity_data = []
        for dc in self.datacenters:
            for server in dc.servers:
                if server.deployed:
                    capacity_data.append({
                        'server_generation': server.generation,
                        'capacity': server.capacity
                    })
        df = pd.DataFrame(capacity_data)
        if not df.empty:
            aggregated = df.groupby('server_generation')['capacity'].sum()
            return aggregated.to_frame('capacity')  # Convert to DataFrame explicitly
        else:
            return pd.DataFrame(columns=['capacity'])  # Ensure it's always a DataFrame
        
    def move_server(self, server_id, source_dc_id, target_dc_id):
        source_dc = self.get_datacenter_by_id(source_dc_id)
        target_dc = self.get_datacenter_by_id(target_dc_id)

        if source_dc is None or target_dc is None:
            print("Invalid data center ID provided.")
            return False

        # Find the server in the source data center
        server = next((s for s in source_dc.servers if s.identifier == server_id), None)
        if server is None:
            print(f"Server {server_id} not found in {source_dc_id}.")
            return False

        # Check if target data center has enough slots
        if not target_dc.can_add_servers(server.slots_needed):
            print(f"Not enough slots in {target_dc_id} to accommodate server {server_id}.")
            return False

        # Move the server
        self.remove_server(server, source_dc)
        self.add_server(server, target_dc, moving=True)
        server.data_center = target_dc
        print(f"Server {server_id} moved from {source_dc_id} to {target_dc_id}.")
        # Update the moving cost
        self.delta_moving_cost += server.cost_of_moving
        self.current_moving_cost += server.cost_of_moving
        return True
    
    def remove_server(self, server_id, datacenter_id):
        datacenter = self.get_datacenter_by_id(datacenter_id)
        if datacenter is None:
            print(f"Data center with ID {datacenter_id} not found.")
            return False

        # Find the server in the data center
        server = next((s for s in datacenter.servers if s.identifier == server_id), None)
        if server is None:
            print(f"Server {server_id} not found in {datacenter_id}.")
            return False

        # Remove the server
        datacenter.servers.remove(server)
        server.decommission()
        print(f"Server {server_id} removed from {datacenter_id}.")
        return True
    
    def add_server(self, server, datacenter_id, moving=False):
        # Fetch the data center
        datacenter = self.get_datacenter_by_id(datacenter_id)
        if datacenter is None:
            print(f"Data center with ID {datacenter_id} not found.")
            return False

        # Check if enough slots are available
        if datacenter.can_add_serve(server):
            datacenter.servers.add_servers(server)
            server.deploy()
            print(f"Server {server.identifier} added to {datacenter_id}")
            if not moving:
                self.delta_purchase_cost += server.purchase_price
                self.current_purchase_cost += server.purchase_price
            return True
        else:
            print(f"Not enough slots to add server {server.identifier} to {datacenter_id}")
            return False

    def update(self):
        '''
        Updates the aging and time_step of the inventory for one time step, including all data centers and servers.
        '''
        self.operational_time += 1
        for dc in self.datacenters:
            dc.update()

    def __str__(self):
        """ Provides a string representation of the inventory for debugging purposes. """
        return f"Inventory with Datacenters: {[dc.identifier for dc in self.datacenters]}"

class ProblemData:
    def __init__(self):
        self.datacenters_df, self.servers_df, self.selling_prices_df = load_problem_data_without_demand()
        print("IMPORTANT: The ProblemData Class should not be changed. It is used to load the data for the problem.")
        print("Columns and Head of ProblemData: datacenters_df: ")
        print(self.datacenters_df.columns)
        print(self.datacenters_df)
        print("Columns and Head of ProblemData: servers_df: ")
        print(self.servers_df.columns)
        print(self.servers_df)
        print("Columns and Head of ProblemData: selling_prices_df: ")
        print(self.selling_prices_df.columns)
        print(self.selling_prices_df)
        print("IMPORTANT: The ProblemData Class should not be changed. It is used to load the data for the problem.")

class InputDemandDataActual:
    def __init__(self, seed=None):
        np.random.seed(seed)
        self.sample_demand_data_df = load_demand()
        self.demand_data_df = self.adjust_demand_with_hackathon_method(self.sample_demand_data_df)
        print("IMPORTANT: The InputDemandDataActual AND YOUR ORIGINAL COPIES should not be changed BECAUSE THE AGENT NEEDS TO BE TRAINED ON THE ORIGINAL INPUT FORMAT HOW THEY APPEAR.")
        print("Columns and Head of Hackathon Input Format demand data: ")
        print(self.demand_data_df.columns)
        print(self.demand_data_df.head())
        print("IMPORTANT: The InputDemandDataActual AND YOUR ORIGINAL COPIES should not be changed BECAUSE THE AGENT NEEDS TO BE TRAINED ON THE ORIGINAL INPUT FORMAT HOW THEY APPEAR.")
        '''
        Logic on the other parts of the project need to be adjusted to understand the format of the Hackathon Input Format demand data.
        This Class or the input data should not be changed.
        Change how you handle the data in the other parts of the project with regards to required_capacity.
        '''

    def adjust_demand_with_hackathon_method(self, demand_df):
        return get_actual_demand(demand_df)

Filename: application_training.py
Path: application_training.py

from stable_baselines3 import PPO
from envs.server_management_env import ServerManagementEnv
from Classes import *

def train_model():
    givens = ProblemData()
    actual_demand = InputDemandDataActual(seed=42)
    env = ServerManagementEnv(givens, actual_demand)
    print(env)

    # Using a model to train
    model = PPO('MlpPolicy', env, verbose=1)

    obs = env.reset()
    print("Initial Observation:", obs)
    
    # Perform multiple steps
    for _ in range(100):  # Define the number of steps or use a more complex termination condition
        action = model.predict(obs, deterministic=True)[0]
        print(f"Predicted Action: {action}")
        obs, reward, done, info = env.step(action)
        print(f"Action: {action}, Observation: {obs}, Reward: {reward}, Done: {done}")

        if done:
            obs = env.reset()  # Reset the environment when a terminal state is reached

    model.save("server_management_rl_model")
    print("Training completed and model saved.")

if __name__ == "__main__":
    print("Training the model...")
    train_model()


Filename: server_management_env.py
Path: envs/server_management_env.py

import gymnasium as gym
from gymnasium import spaces
import numpy as np
from Classes import *

class ServerManagementEnv(gym.Env):
    def __init__(self, givens, demand_data):
        super().__init__()
        self.givens = givens
        self.current_time_step = 1
        self.current_demand_rows = demand_data.demand_data_df[demand_data.demand_data_df['time_step'] == self.current_time_step]
        self.inventory = Inventory(givens)
        num_data_centers = len(self.inventory.datacenters) # e.g., DC1, DC2, DC3, DC4
        num_server_types = len(self.givens.servers_df['server_type'].unique()) # e.g., CPU.S1, CPU.S2, CPU.S3, CPU.S4, GPU.S1, GPU.S2, GPU.S3
        num_action_types = 3  # e.g., add, remove, move
        max_quantity = 10  # Max units per action

        self.action_space = spaces.MultiDiscrete([num_data_centers, num_server_types, num_action_types, max_quantity])
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(10,), dtype=np.float32)
        self.state = self.reset()

    def map_numbers_to_action(self, action):
        if action == 0:
            return 'buy'
        elif action == 1:
            return 'hold'
        elif action == 2:
            return 'move'

    def reset(self):
        # Initialize the environment state at the start of each episode
        self.state = self.initialize_environment_state()
        return self.convert_state_to_observation(self.state)

    def initialize_environment_state(self):
        state = {}

        # Initialization for each data center according to specified metrics
        for i, dc in enumerate(self.inventory.datacenters):
            dc_id = dc.identifier  # Identifiers like 'DC1', 'DC2', etc.
            state[f"{dc_id}_TOTAL_SERVERS"] = 0
            state[f"{dc_id}_OPERATIONAL_SERVERS"] = 0
            state[f"{dc_id}_ENERGY_CONSUMPTION"] = 0.0
            state[f"{dc_id}_AVAILABLE_SLOTS"] = dc.slots_capacity
            state[f"{dc_id}_ENERGY_COST"] = dc.cost_of_energy
            state[f"{dc_id}_UTILIZATION_RATE"] = 0.0

            # Server type counts within this data center
            for server_type in self.givens.servers_df['server_type'].unique():
                state[f"{dc_id}_COUNT_{server_type}"] = 0  # Initialize count for each server type

        # System-wide aggregate metrics
        state["SYSTEM_TOTAL_OPERATING_COST"] = 0.0
        state["TOTAL_DEMAND_MET"] = 0
        state["TOTAL_SERVERS_DEPLOYED"] = 0
        state["TOTAL_CAPACITY_USED"] = 0

        # Server lifecycle metrics focusing on the aging and utilization of servers
        state["SERVERS_NEAR_EOL"] = 0  # Servers nearing end-of-life
        state["SERVERS_MID_LIFE"] = 0  # Servers at mid-life stage
        state["SERVERS_NEW"] = 0       # Recently deployed servers

        # Detailed tracking of energy usage and server demand
        state["TOTAL_ENERGY_COST"] = 0.0
        state["TOTAL_ENERGY_CONSUMPTION"] = 0.0
        state["TOTAL_FAILURES"] = 0
        state["AVERAGE_LATENCY"] = 0.0
        state["AVERAGE_OPERATIONAL_EFFICIENCY"] = 0.0

        # Initialize demand-related metrics for each server type, adjusted by the demand data
        for server_type in self.givens.servers_df['server_type'].unique():
            state[f"DEMAND_{server_type}"] = 0  # Placeholder, to be updated dynamically with demand data

        # Economic factors such as profitability calculations
        state["REVENUE_FROM_DEPLOYMENT"] = 0.0
        state["COST_OF_DEPLOYMENTS"] = 0.0
        state["NET_PROFIT"] = 0.0

        # Optional: Tracking specific server attributes could be useful for advanced metrics
        for server_type in self.givens.servers_df['server_type'].unique():
            for attr in ['capacity', 'life_expectancy', 'energy_consumption']:
                state[f"TOTAL_{attr.upper()}_{server_type}"] = 0

        return state

    def convert_state_to_observation(self, state):
        # Convert the state dictionary to a numpy array for the observation
        # This list should include all keys from the state dictionary that you consider relevant for the agent's decision-making process.
        observation_keys = [
            key for key in state.keys()  # This captures all keys dynamically
        ]
        return np.array([state[key] for key in observation_keys])


    def step(self, action):
        dc_id, server_type, action_type, quantity = action
        data_center = self.inventory.datacenters[dc_id]
        if action_type == 0:  # Buy
            server_info = self.givens.servers_df[self.givens.servers_df['server_type'] == server_type].iloc[0]
            slots_needed = server_info['slots_size'] * quantity
            if data_center.empty_slots >= slots_needed:
                data_center.deploy_server(server_type, quantity)
            else:
                print(f"Not enough slots to deploy {quantity} servers of type {server_type}.")
                reward = -1  # Penalize the attempt to buy without enough slots
        elif action_type == 1:  # Move
            self.inventory.move_server(dc_id, server_type, quantity)
        elif action_type == 2:  # Remove
            self.inventory.remove_server(dc_id, server_type, quantity)

        self.state = self.update_state()
        observation = self.convert_state_to_observation(self.state)
        reward = self.calculate_reward()  # Update reward based on the action's success or failure
        done = self._check_done()
        info = {}

        self.current_time_step += 1
        self.current_demand_rows = self.demand_data.demand_data_df[self.demand_data.demand_data_df['time_step'] == self.current_time_step]

        return observation, reward, done, info

    def update_state(self):
        # Simulate the passing of one time unit in the environment
        for datacenter in self.inventory.datacenters:
            datacenter.simulate_time_step()

        # Reset or update the system-wide metrics
        system_total_operating_cost = 0.0
        total_demand_met = 0
        total_servers_deployed = 0
        total_capacity_used = 0
        total_energy_cost = 0.0

        # Iterate over each data center to update their respective metrics
        for i, dc in enumerate(self.inventory.datacenters):
            dc_id = dc.identifier
            summary = dc.summary()

            # Update data center specific metrics
            self.state[f"{dc_id}_TOTAL_SERVERS"] = len(dc.servers)
            self.state[f"{dc_id}_OPERATIONAL_SERVERS"] = sum(1 for s in dc.servers if s.deployed)
            self.state[f"{dc_id}_ENERGY_CONSUMPTION"] = summary['energy_cost']
            self.state[f"{dc_id}_AVAILABLE_SLOTS"] = dc.empty_slots
            self.state[f"{dc_id}_UTILIZATION_RATE"] = summary['utilization_rate']

            # Aggregate the system-wide metrics
            system_total_operating_cost += summary['operational_cost']
            total_capacity_used += summary['used_capacity']
            total_energy_cost += summary['energy_cost']
            total_servers_deployed += self.state[f"{dc_id}_OPERATIONAL_SERVERS"]
            total_demand_met += summary['demand_met']  # Assuming you calculate this somewhere

        # Update the system-wide state variables
        self.state["SYSTEM_TOTAL_OPERATING_COST"] = system_total_operating_cost
        self.state["TOTAL_DEMAND_MET"] = total_demand_met
        self.state["TOTAL_SERVERS_DEPLOYED"] = total_servers_deployed
        self.state["TOTAL_CAPACITY_USED"] = total_capacity_used
        self.state["TOTAL_ENERGY_COST"] = total_energy_cost

        # Calculate averages or other derived metrics
        self.state["AVERAGE_LATENCY"] = np.random.random()  # Update with actual computation if available
        self.state["AVERAGE_OPERATIONAL_EFFICIENCY"] = np.random.random()  # Update with actual computation if available

        return self.state

    def calculate_reward(self, state):
        # Example reward calculations based on state variables
        demand_met = state['demand_met']
        capacity_used = state['capacity_used']
        total_capacity = state['total_capacity']
        
        reward = 0
        reward += demand_met * 1  # Reward for each unit of demand met
        reward -= (total_capacity - capacity_used) * 0.5  # Penalty for unused capacity
        
        # Additional penalties or rewards can be added based on other factors
        return reward


    def _check_done(self):
        # Determine whether the episode should end
        return np.random.rand() > 0.95

